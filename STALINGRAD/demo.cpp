#include <bits/stdc++.h>#define oo 20000000000000#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);#define int long long#define FOR(i,a,b) for(int i = a; i <= b; i++)#define FOD(i,a,b) for(int i = b; i >= a; i--)#define REP(i,a) for(int i = 0; i < a; i++)#define MASK(i) (1LL << (i))#define BIT(i, a) (((a) >> (i)) & 1)#define LOG 19#define NMOD 3const int BASE = 256;const long long MOD[] = {(int)1e9 + 2277, (int)1e9 + 5277, (int)1e9 + 8277, (int)1e9 + 9277};using namespace std;#define MAX 50050int pw[NMOD][MAX];void prepare(void){    for (int j = 0 ; j < NMOD; j++) {        pw[j][0] = 1;        for (int i = 1; i < MAX; i++) pw[j][i] = 1LL * pw[j][i - 1] * BASE % MOD[j];    }}struct Hash{    int value[NMOD];    Hash(){        memset(value, 0, sizeof value);    }    Hash(char c){        for (int j = 0; j < NMOD; j++) value[j] = c;    }    Hash operator + (const Hash &x) const {        Hash res;        for (int j = 0; j < NMOD; j++) {            res.value[j] = value[j] + x.value[j];            if (res.value[j] -= MOD[j]) res.value[j] -= MOD[j];        }        return res;    }    Hash operator - (const Hash &x) const {        Hash res;        for (int j = 0; j < NMOD; j++) {            res.value[j] = value[j] - x.value[j];            if (res.value[j] < 0) res.value[j] += MOD[j];        }        return res;    }    Hash operator * (int k) const{        Hash res;        for (int j = 0; j < NMOD; j++) res.value[j] = 1LL * value[j] * pw[j][k] % MOD[j];        return res;    }    bool operator < (const Hash &x) const {        for (int j = 0; j < NMOD; j++) if (value[j] != x.value[j])        return value[j] < x.value[j];        return false;    }    bool operator == (const Hash &x) const {        for (int j = 0; j < NMOD; j++) if (value[j] != x.value[j]) return false;        return true;    }};template<class T> T Abs(const T &x) { return (x < 0 ? -x : x); }template<class X, class Y>bool minimize(X &x, const Y &y) {    X eps = 1e-9;    if (x > y + eps) {        x = y;        return true;    } else return false;}template<class X, class Y>bool maximize(X &x, const Y &y) {    X eps = 1e-9;    if (x + eps < y) {        x = y;        return true;    } else return false;}template <typename T>inline void Read(T& x) {    bool Neg = false;    char c;    for (c = getchar(); c < '0' || c > '9'; c = getchar())        if (c == '-') Neg = !Neg;    x = c - '0';    for (c = getchar(); c >= '0' && c <= '9'; c = getchar())        x = x * 10 + c - '0';    if (Neg) x = -x;}template <typename T>inline void Write(T x) {    if (x < 0) { putchar('-'); x = -x; }    T p = 1;    for (T temp = x / 10; temp > 0; temp /= 10) p *= 10;    for (; p > 0; x %= p, p /= 10) putchar(x / p + '0');}using ii = pair <int, int>;using ll = long long;using ld = long double;const int Nmax = 400400;int n, q, par[Nmax][LOG + 1];vector <int> a[Nmax];int h[Nmax], D[Nmax], numChild[Nmax], sta[Nmax], cnt = 0, goc[Nmax], res = 0, top[Nmax], numBlock = 0, numRoad = 0;set <int> Active[Nmax];void dfs(int u, int top){    goc[u] = top;    sta[u] = ++cnt;    numChild[u] = 1;    D[cnt] = u;    for(auto v : a[u]){        h[v] = h[u] + 1;        dfs(v, top);        numChild[u] += numChild[v];    }}int lca(int u, int v){    if(h[u] < h[v]) swap(u, v);    FOD(i,0,LOG) if(h[par[u][i]] >= h[v]) u = par[u][i];    if(u == v) return u;    FOD(i,0,LOG) if(par[u][i] != par[v][i]){        u = par[u][i];        v = par[v][i];    }    return par[u][0];}int getNode(const set<int> &active){    if (active.empty()) return 0;    __typeof(active.begin()) it = active.begin();    int left = D[*it];    it = active.end(); it--;    int right = D[*it];    return lca(left, right);}void push_active(int x){    int t = goc[x];    if(Active[t].empty()) numRoad++;    Active[t].insert(sta[x]);    int ParentNode = getNode(Active[t]);    numBlock++;    res += numChild[ParentNode] - numChild[top[t]];    top[t] = ParentNode;}void pop_active(int x){    int t = goc[x];    Active[t].erase(sta[x]);    if(Active[t].empty()) numRoad--;    int ParentNode = getNode(Active[t]);    numBlock--;    res += numChild[ParentNode] - numChild[top[t]];    top[t] = ParentNode;}void readfile(){    FASTIO    freopen("STALINGRAD.INP", "r", stdin);    freopen("STALINGRAD.OUT", "w", stdout);    int subtask; cin >> subtask;    cin >> n >> q;    FOR(i,2,n){        int p; cin >> p;        par[i][0] = p;        a[p].push_back(i);    }    h[0] = -1;    FOR(j,1,LOG) FOR(i,1,n) par[i][j] = par[par[i][j-1]][j-1];    for(auto x : a[1]){        h[x] = 1;        dfs(x,x);    }    //FOR(i,1,n) cout << numChild[i] << '\n';    char sign[5];    int x;    FOR(i,1,q){        cin >> sign >> x;        if(sign[0] == '+') push_active(x);        if(sign[0] == '-') pop_active(x);        cout << numRoad << " " << res - numBlock << '\n';    }}int32_t main(){    readfile();    return 0;}